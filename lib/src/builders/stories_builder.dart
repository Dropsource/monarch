import 'dart:async';

import 'package:build/build.dart';
import 'package:analyzer/dart/element/element.dart';
import 'package:path/path.dart' as p;
import 'package:dart_style/dart_style.dart';

class StoriesBuilder implements Builder {
  @override
  Map<String, List<String>> get buildExtensions => {
        '.stories.dart': ['.stories.g.dart']
      };

  @override
  FutureOr<void> build(BuildStep buildStep) async {
    logFine('Processing: ${buildStep.inputId}');

    final entryLib = await buildStep.inputLibrary;

    final inputId = buildStep.inputId;

    // changing extension from `.stories.dart` to `.stories.g.dart`
    final outputPath = p.setExtension(inputId.path, '.g.dart');

    final outputId = AssetId(inputId.package, outputPath);

    var storiesNames = <String>[];
    var storiesMap = <String, String>{};

    for (var topLevelElement in entryLib.topLevelElements) {
      if (topLevelElement is FunctionElement) {
        if (topLevelElement.returnType.element.name == 'Widget') {
          final storyName = topLevelElement.name;
          final storyNameInSingleQuotes = "'$storyName'";
          logFine('Found story: $storyName');
          storiesNames.add(storyNameInSingleQuotes);
          storiesMap[storyNameInSingleQuotes] = storyName;
        } else {
          logFine(
              'Top level function is not story, return type is not Widget: ${topLevelElement.name}');
        }
      } else {
        logFine(
            'Top level element is not story, it is not FunctionElement: ${topLevelElement.name}');
      }
    }

    final storiesSource = await buildStep.readAsString(buildStep.inputId);
    final output = _outputContents(storiesSource, inputId, storiesNames, storiesMap);

    var formatter = DartFormatter();
    var formattedOutput = formatter.format(output);

    await buildStep.writeAsString(outputId, formattedOutput);
  }

  static int storiesSourceLineOffset = 3;

  String _outputContents(String storiesSource, AssetId storiesAssetId, List<String> storiesNames,
      Map<String, String> storiesMap) {
    // @GOTCHA: when changing the output contents, 
    // make sure to update [storiesSourceLineOffset].
    return '''
/// GENERATED BY TOOL - PLEASE DO NOT MODIFY
import 'package:dropsource_storybook/dropsource_storybook.dart';

$storiesSource

const storiesData = StoriesData('${storiesAssetId.package}', '${storiesAssetId.path}', [${storiesNames.join(', ')}], $storiesMap);

''';
  }

  void logFine(String message) {
    print('FINE [StoriesBuilder] $message');
  }
}
